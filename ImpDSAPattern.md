Here is a **comprehensive list of key patterns in DSA (Data Structures and Algorithms)**. These patterns help you recognize the best approach for solving a problem—especially useful in interviews and competitive programming.

---

### 🧠 **1. Sliding Window**

Used for problems involving **contiguous subarrays** or substrings.

**When to use:** Fixed-size or variable-size window over arrays/strings.

**Examples:**

* Maximum sum of k-length subarray
* Longest substring without repeating characters
* Minimum window substring

---

### 🔁 **2. Two Pointers**

Efficient when dealing with **sorted arrays or searching for pairs**.

**When to use:** When scanning from both ends or shrinking/expanding pointers.

**Examples:**

* Two Sum (sorted)
* 3Sum / 4Sum
* Reverse string/array in-place
* Container With Most Water

---

### 🔄 **3. Fast & Slow Pointers (Floyd's Cycle Detection)**

Used for **cycle detection** in linked lists or arrays.

**When to use:** Loop/cycle detection, middle of linked list.

**Examples:**

* Linked list cycle
* Find the start of the cycle
* Happy number
* Detecting middle of linked list

---

### 🗃️ **4. Prefix Sum / Difference Array**

Used to **precompute ranges** for fast queries.

**When to use:** Range sum, range frequency, difference calculations.

**Examples:**

* Subarray sum equals K
* Range sum queries
* Number of subarrays with sum divisible by K

---

### 🔍 **5. Binary Search**

Used to search **efficiently in sorted arrays or on monotonic conditions**.

**Variants:**

* Binary Search on Answer (value space)
* Lower Bound / Upper Bound

**Examples:**

* Search in Rotated Sorted Array
* Kth smallest pair/product
* Allocate minimum pages
* Median of two sorted arrays

---

### 🛠️ **6. Bit Manipulation**

Efficiently solve problems involving binary representation.

**When to use:** XOR patterns, subsets, toggling bits.

**Examples:**

* Single Number / Single Number II
* Counting set bits
* Subsets using bitmask
* Power of two

---

### 🌳 **7. DFS / BFS (Graph or Tree Traversal)**

Explore nodes/edges using Depth or Breadth first approaches.

**When to use:** Graph traversal, tree problems, pathfinding.

**Examples:**

* Clone graph
* Detect cycle in graph
* Number of islands
* Shortest path in binary matrix

---

### 🧭 **8. Backtracking**

Recursive approach to explore **all valid configurations**.

**When to use:** Combinatorics, permutations, Sudoku.

**Examples:**

* N-Queens
* Generate Parentheses
* Word Search
* Subset Sum / Combinations

---

### 💥 **9. Greedy**

Make **locally optimal choices** with hope for global optimum.

**When to use:** Interval problems, minimal operations, scheduling.

**Examples:**

* Activity Selection
* Jump Game
* Gas Station
* Fractional Knapsack

---

### 📊 **10. Heap / Priority Queue**

Used to process **dynamic largest/smallest values efficiently**.

**When to use:** Top k elements, Dijkstra’s algorithm, scheduling.

**Examples:**

* Kth largest element
* Merge k sorted lists
* Median in data stream
* Reorganize string

---

### 🧮 **11. Hashing / Map / Set**

Used to achieve **constant-time lookups**.

**When to use:** Frequency counting, fast searching, duplicates.

**Examples:**

* Two Sum
* Group Anagrams
* Longest Consecutive Sequence
* Subarray sum equals k

---

### 🔁 **12. Dynamic Programming (DP)**

Break down problems into **overlapping subproblems + optimal substructure**.

**Types:**

* Memoization (Top-down)
* Tabulation (Bottom-up)
* Space Optimization

**Examples:**

* 0/1 Knapsack
* Longest Increasing Subsequence
* House Robber
* Edit Distance

---

### 🧱 **13. Union Find / Disjoint Set**

Used for **connected components and efficient merges**.

**When to use:** Graph components, Kruskal’s algorithm.

**Examples:**

* Connected components
* Redundant connection
* Number of provinces
* Accounts merge

---

### 🔤 **14. Trie (Prefix Tree)**

Efficient structure for **word storage and retrieval**.

**When to use:** Word prefixes, autocomplete, word search.

**Examples:**

* Implement Trie
* Word Search II
* Replace Words

---

### 🧮 **15. Combinatorics / Math Patterns**

Used when **counting** combinations, permutations, or modular arithmetic.

**Examples:**

* Pascal’s Triangle
* Catalan Numbers
* Combination Sum
* Count Unique BSTs

---

### ⚖️ **16. Monotonic Stack / Queue**

Used to maintain **increasing/decreasing order** for quick lookups.

**When to use:** Nearest greater/smaller element, sliding max.

**Examples:**

* Next Greater Element
* Largest Rectangle in Histogram
* Daily Temperatures
* Sliding Window Maximum

---

### 🧬 **17. Segment Tree / Binary Indexed Tree**

Used for **range queries and updates**.

**When to use:** Sum, min, max, or frequency queries.

**Examples:**

* Range sum with updates
* Count of smaller numbers after self
* Kth smallest in subarray

---

### 📈 **18. Topological Sort / Kahn’s Algorithm**

Used to **order tasks based on dependencies** (DAGs).

**Examples:**

* Course Schedule
* Alien Dictionary
* Task Scheduling

---

### 🔁 **19. Matrix Traversal**

Special handling of **2D arrays** for spirals, diagonals, etc.

**Examples:**

* Spiral Matrix
* Search in a 2D Matrix
* Number of islands
* Rotting Oranges

---

### 🧠 **20. Pattern Recognition + Frequency Maps**

For problems that involve **counting patterns or palindromes**.

**Examples:**

* Longest Palindromic Substring
* Anagram substrings
* Repeated DNA sequences

---

### 🧩 Bonus Patterns

* **Meet in the Middle** – Split into halves for large constraints.
* **Reservoir Sampling** – For random selection in stream data.
* **Suffix Arrays / Z-Algorithm** – For efficient string search.
* **Line Sweep** – For interval and geometry problems.

---
